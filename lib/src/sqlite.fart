import 'dart:io';
import 'package:path/path.dart';
import 'package:path_provider/path_provider.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:phone_control/documents/common.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';
import 'package:pkg_utils/pkg_utils.dart';
import 'package:pkg_widgets/pkg_widgets.dart';
import '../config.dart';
import 'package:flutter/foundation.dart';
//import 'user.dart';

bool _mutexDbAccess = false; // false: available, true: busy

DbStorageInit dbInit = DbStorageInit();

/* class DbStorageInit {
  late String dbPath;
  bool isInit = false; // true when init() is done. Usefull with async :()

  static Future<String> getDbPath() async {
    String path;
    if (OS.isMobile()) {
      path = join((await getApplicationSupportDirectory()).path, "storage.db");
    } else {
      if (kDebugMode) {
        path = join(Directory.current.path, 'assets', 'db', 'storage.db');
      } else {
        path =
            join((await getApplicationSupportDirectory()).path, "storage.db");
      }
    }
    return path;
  }

  static String getDbAssetPath() {
    return "assets/db/storage.db";
  }

  Future<String> init() async {
    if (OS.isDesktop()) {
      // Initialize FFI
      sqfliteFfiInit();
      databaseFactory = databaseFactoryFfi;
    }
    dbPath = await getDbPath();
    await _initDbFromAssets();

    isInit = true;
    return dbPath;
  }

  _initDbFromAssets() async {
    assert(dbPath != "");

    if (forceDatabaseOverwriteFromInstall) {
      File file = File(dbPath);
      if (file.existsSync()) {
        file.deleteSync();
        //return;
      }
    }

// Only copy if the database doesn't exist
    if (FileSystemEntity.typeSync(dbPath) == FileSystemEntityType.notFound) {
      ByteData data;
      // Load database from asset and copy

      //if (kReleaseMode) {

      data = await rootBundle.load(getDbAssetPath());

      List<int> bytes =
          data.buffer.asUint8List(data.offsetInBytes, data.lengthInBytes);

      // Save copied asset to documents
      await File(dbPath).writeAsBytes(bytes);
    }
  }
} */

class DbStorage {
  late Database _db;

  bool _isOpen = false;

  late DbStorageInit initDB;

  DbStorage(this.initDB);

  /// open db if needed
  Future<void> open() async {
    // wait for init() is done
    while (initDB.isInit == false) {
      //print("wait initDB.isInit");
      await Future.delayed(const Duration(milliseconds: 10));
    }
    // whait for mutex
    while (_mutexDbAccess == true) {
      //print("wait _mutexDbAccess");
      await Future.delayed(const Duration(milliseconds: 10));
    }
    _mutexDbAccess = true;
    assert(await testDelay());

    if (_isOpen == true) return; // false;
    _db = await openDatabase(initDB.dbPath);
    _isOpen = true;
  }

  /// close db
  Future<void> close() async {
    assert(_isOpen == true);
    await _db.close();
    _isOpen = false;
    _mutexDbAccess = false;
  }

  Future<Map<String, dynamic>?> fromDatabaseByID({
    required String sTable,
    required String? sID,
  }) async {
    try {
      return (await fromDatabase(
              sTable: sTable, where: "sID=?", whereValues: [sID], limit: 1))
          .first;
    } catch (e) {
      Console.printColor(PrintColor.red, e.toString());
      return null;
    }
  }

  Future<List<Map<String, dynamic>>> fromDatabase(
      {required String sTable,
      List<String>? columns,
      String? where,
      List<Object?>? whereValues,
      int? limit,
      String? orderBy}) async {
    assert(await testDelay());
    List<Map<String, dynamic>> list = await _db.query(sTable,
        columns: columns,
        where: where,
        whereArgs: whereValues,
        limit: limit,
        orderBy: orderBy);
    return list;
  }

  Future<void> toDatabase(
      {required Map<String, dynamic> map, required String sTable}) async {
    assert(await testDelay());
    await _db.insert(
      sTable,
      map,
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<void> sqlExecute(String sql) async {
    assert(await testDelay());
    assert(_isOpen == true);
    await _db.execute(sql);
  }

  Future<List<Map>> sqlQuery(String sql) async {
    assert(sql.trim().isNotEmpty);
    assert(await testDelay());
    assert(_isOpen == true);
    List<Map> list = await _db.rawQuery(sql);
    return list;
  }
}

extension SQLListExtensionString on List<String> {
  // Copyright ChatGPT :)
  String toSql() {
    final values = map((item) => "'$item'").join(',');
    return values;
  }
}

extension SQLListExtensionNumber on List<num> {
  // Copyright ChatGPT
  String toSql() {
    final values = map((item) => "$item").join(',');
    return values;
  }
}
